<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WED Zusammenfassung</title>
  <link href="./node_modules/prismjs/themes/prism.css" rel="stylesheet" />
  <link href="./style.css" rel="stylesheet" />
</head>
<body>
  <div class="container page1">
    <div class="item itemBig row1">
      <h1>CSS Grid</h1>
      <pre class="code"><code class="language-css">#grid-container {
  display: grid; //inline-grid: inline | grid: block-level
  width: 100px;
  grid-template-columns: 1fr 60px minmax(10px, 200px);
  grid-template-rows: 1fr 1fr;
  grid-template-areas: 
    'nav nav nav nav'
    'toc item item .'
    'toc item item .'
    'footer footer footer footer';
  align-items: auto | normal | start | end |
   center |stretch | baseline;
  justify-items: auto | normal | start | end |
   center |stretch | baseline;
}
.item {
/*Shorthand for 'grid-row-start' and 'grid-row-end'.
  span Anzahl columns von 1*/
  grid-row: 1 / span 2;
  grid-column: 1 
  gap: 10px;
/*Is a shorthand property for the grid-row-start,
  grid-column-start, grid-row-end, 
  and grid-column-end in that order. 
  Each value is separated by a /.*/
  grid-area: 2 / 1 / span 2 / span 3;
/*Es kann auch ein Name vergeben werden, der dann 
  in grid-template-areas gebraucht werden kann*/
  grid-area: item;
/*inherits align-items if defined overwrites align-items value*/
  align-self: center; 
/*inherits justify-items if defined overwrites justify-items value*/
  justify-self: auto | normal | start;
}
nav {grid-area: nav;}
.side-toc {grid-area: toc;  }
footer {grid-area: footer;}</code></pre>
    </div>
    <div class="item itemBig row2">
      <h1>CSS Flexbox</h1>
      <p><span class="subtitle">Facts:</span>Alle Elemente Verhalten sich wie "inline blocks" (erlaubt margin (left & right) und paddding,
        erlaubt andere Elemente auf der gelichen Zeile, erlaubt <b>width</b> und <b>height</b>
      </p>
      <p><span class="subtitle">flex-grow:</span>
        Entspricht dem Verhältnis wie der leere Platz verteilt wird. Default: 0 (nicht grösser werden)
      </p>
      <p><span class="subtitle">flex-shrink</span>
        Entspricht dem Verhältnis wie die Elemente kleiner werden, wenn zu wenig PLatz vorhanden ist, Default: 0
      </p>
      <p><span class="subtitle">flex-basis</span>
        Alternative: content | Ist initialer Wert für Grösse eines flex item. flex-direction: row -A value steht für width, 
        column -> value steht für Breite
      </p>
      <p><span class="subtitle">flex-wrap:</span>
        Problem: zuviele Elemente in einer Reihe
      </p>
      <p><span class="subtitle">(flex-order) order:</span>
        Werden in aufsteigender Reihenfolge dargestellt, Default: 0
      </p>
      <pre class="code"><code class="language-css">.container {
  display: flex;
  flex-direction: row | row-reverse 
  | column | column-reverse
  flex-wrap: wrap;
  flex-flow: [flex-direction] [flex-wrap]
  align-items: stretch;
/*nur sinvoll bei fixer Item Grösse*/
  justify-content: center;
}
.item {
  flex-grow: 1;
  flex-shrink: 1; 
  flex-basis: 20px;
  flex: [flex-grow] [flex-shrink] [flex-basis];
}
.baboItem {
  order: -1;
} </code></pre>
    </div>
    <div class="item itemSmall row2">
      <h1>User Centered Design</h1>
      <p><span class="subtitle">Zsm:</span>Den user befragen ist <b>nicht</b> User Centerd Design, 
        sondern beobachen was sie machen.
      </p>
      <p>
        <span class="subtitle">Stolze:</span> You may ask you customers, but not your users.
        Man sollte sich bewusst sein, wer der User ist.
      </p>
      <p>
        <span class="subtitle">Features of Good User Research:</span>
        Representative Benutzer auswählen, Sinvolle und realistische Tests machen, 
        momentante tools und strategies verwenden, in einem sinvollen und representativen context
      </p>
      <p>
        <span class="subtitle">Information Scent:</span> 
        Links etc. sind so bennant, dass klar ist welche Ziele durch die Navigation erreich (und nicht erreicht) werden.
      </p>
      <p>
        <span class="subtitle">Site Map: </span> Baumstruktur der Navigation
      </p>
      <p>
        <span class="subtitle">Raster Design: </span> Gute "Ausschilderung" User sollten stets wissen: 
        <ul>
          <li>Wo bin ich im Moment: Eindeutiger Seitentitel, konsistenter Header, Icons, Seitendesign, Was kann ich machen</li>
          <li>Wo kann ich hin: Deutlich sichtbare Navigationselemente</li>
          <li>Was ist passiert: Navigation z.B. animiert, Browser back unterstützen</li>
        </ul>
      </p>
      <p>
        <span class="subtitle">Usability: </span>
        <ul>
          <li>Effektivität: Benutzer könne Ziele erreichen</li>
          <li>Effizienz: Benutzer können ihre Ziele mit angemessenem Aufwand erreichen</li>
          <li>Zufriedenheit: Benutzer sind positiv gegenüber dem System eingestellt</li>
        </ul>
      </p>
      <p>
        <span class="subtitle">Card Sorting: </span>
        <b>Schritt 1: </b>Content Repository Erstellen (Was sind Zielpunkte der Navigation)</p>
      <p>
        <b>Schritt 2: </b>
        <ul>
          <li>"Open Card Sort" 5+ Personen aus der Zielgruppe rekrutieren</li> 
          <li>Content Elemente in disjunkte (Elemente haben nichts gemeinsam) Gruppen ordnen lassen</li>
          <li>Gruppen benennen lassen</li>
        </ul>
      </p>
      <p>
        <b>Schritt 3: </b>Gute Gruppennamen identifizieren (Hypothese)
      </p>
      <p>
        <b>Schritt 4: </b>Gruppennamen mittels "Closed Card Sort" Validieren
        <ul>
          <li>5+ Neue Personen aus der Zielgruppe rekrutieren</li>
          <li>Gruppenname vorgeben</li>
          <li>Content Elemente den Gruppen zuordnen lassen</li>
        </ul>
      </p>
      <p>
        <span class="subtitle">Tree Testing: </span>
        Aufgabe geben, Geh auf die Seite X. User klickt sich durch und es kann beobachtet werden wie er sich verhaltet.
      </p>
      <p>
        <span class="subtitle">Usability Test</span> Test der die einzelnen Teile der Usability tested, 
        Task beinhaltet den context des Users, das Bedürfnis, das Ziel und den Auslöser
      </p>
    </div>
    <div class="item itemSmall row3" style="min-height: 21cm;">
      <h1>CSS Animation</h1>
      <h2>Transition Properties</h2>
      <pre class="code"><code class="language-css">.ex{
/*which property to change */
  transition-property: prop-name | all | none;
/*how long the transition should take in s or ms*/
  transition-duration: 5ms | 3s;
/*manner in which the transition accelerates*/
  transition-timing-function: ease | linear 
    | ease-in | ease-out 
    | ease-in-out | step-start
    | step-end | steps(...) | cubic-bezier(#,#,#,#);
/*whether there should be apause before starting
  and the duration of said pause*/
  transition-delay: 0.2s;
/*shorthand transition property
  property duration timing-function delay*/
  transition: background-color .3s ease-in 0.2s;
/*transitioning multiple properties*/
  transition: background-color .3s ease-out 1s,
              color 2s ease-in,
              letter-spacing .2s ease-out;
/*defining same duration, timing and
  delay for all transitions*/
  transition: all .2s ease-in-out;
}</code></pre>
      <h2>Transforms</h2>
      <pre class="code"><code class="language-css">.ex{
/*changes shape and rotation of an element*/
  transform: rotate() | rotateX() | rotateY()
    | translate() | translateX() | translateY()
    | scale() | scaleX() | scaleY() 
    | skew() | skewX() |skewY() | none;
/*point ardound which an element is transformed,
  defined by horizontal and vertical offsets*/
  transform-origin: percentage | length | left 
    | center | right | top | bottom;
/*translate() function is used as the value of
  transform to render an element at a new location*/
  transform: translate(90px, 60px) | translate(20%);
}</code></pre>
  <h2>Keyframes</h2>
  <pre class="code"><code class="language-css">@keyframes wiggleAnimation {
  0% { transform: skewX(9deg); }
  10% { transform: skewX(-8deg); }
  20% { transform: skewX(7deg); }
  30% { transform: skewX(-6deg); }
  ...
  90% { transform: skewX(0deg);}
  100% { transform: skewX(0deg); }
}    
.wiggle {
  animation-name: wiggleAnimation;
  animation-duration: 1s;
}</code></pre>
    </div>
    <div class="item itemSmall row4" style="min-height: 21cm;">
      <h1>Testing</h1>
      <p>
        <span class="subtitle">TDD</span>
        Test anything that might break, New Code is quilty until proven innocent, 
        Write at least as much test code as production code
        Run all testc before check-in to repository
      </p>
      <p>
        <span class="subtitle">Unit Tests: </span>Getestet werden einzelne "Units": Klassen, Module (meist ein File)
        Automation relativ einfach, <b>Herausforderung:</b> Isolation der Units, asynchrone Operationen, Testdatengenerierung (z.B. Fuzzing)
      </p>
      <p>
        <span class="subtitle">System Tests: </span>
        Getestet wird das Zusammenspiel aller Systemkomponenten in der Zielumgebung
        Automation meist nur in Teilen möglich.
        <b>Herausforderungen</b>: Realistische aber vorhersagbare Umgebung
        <b>Weitere System Tests:</b>Load Tests, Performance Tests, Endurance Tests, Chaos Tests, Security Tests, Usability Tests
      </p>
      <p>
        <span class="subtitle">Integration Tests: </span>Getestet wird das Zusammenspiel 2 oder mehr "Units"
         (E2E: Integration über alle Layer), Automation meist möglich
        <b>Herausforderungen:</b> Isolation der Units, asynchrone Operationen, Simulation Browser &
        Benutzerinteraktion, Test mit Datenbank, Testdatengenerierung (z.B. Fuzzing)
      </p>
      <p>
        <span class="subtitle">(Visuelle) Regression Tests: </span>
        Getestet wird ob Veränderungen im Code zu (unerwarteten) Änderungen im Verhalten (oder UI)
        führen. Automation möglich mit speziellen Tools
      </p>
      <p>
        <span class="subtitle">Test-Runner: </span>Ein Rhamen der Tests entgegennimmt, ausführt und die Resultate anzeigt.
        <b>Beispiele:</b> Jest, Mocha, Jasmin
      </p>
      <p>
        <span class="subtitle">Assertion-Libraries: </span>
        Code zur Ausführung einzelner Tests
        <b>Beispiele: </b> Assert, Chai, Expect.js
      </p>
      <p>
        <span class="subtitle">Mocking-Library: </span>
        Separierung von Units / Erstellung von Mocks etc.
        <b>Beispiele: </b>Expect.js, Proxyquire, Sinon.js
      </p>
      <p>
        <span class="subtitle">Phasen eines Tests</span>
        <ul>
          <li><b>Setup:</b> beforeEach Initailization, selbe Ausgangslage für alle Tests</li> 
          <li><b>Exercise:</b> Aufruf einer Funktion (mit return value)</li>
          <li><b>Verify:</b> Überprüfen von Anhahmen</li>
          <li><b>Teardown:</b> Zurücksetzen</li>
        </ul>
      </p>
      <p>
        <span class="subtitle">Beispiele</span>
        <pre class="code"><code class="language-javascript">const chai = require('chai');
const expect = chai.expect;
describe("A new bank account", function() {
  beforeEach(function() {
    this.account = new BankAccount();
  });
  afterEach(function() {
    console.log("After the Test");
  })
  it("is initialized by a balance of 0",
  function() {
    expect(this.account.balance).to.equal(0);
  });
  it("should not allow a withdraw",
   function() {
    expect(this.account.withdraw(50))
    .to.equal(false);
    expect(this.account.balance).to
    .throw(new NoMoneyError("No money"));
  });
});</code></pre>
      </p>
      <p>
        <span class="subtitle">Chai Chains:</span>
        <ul>
          <li>.to, .be, .been, .is, .that, .which, .and, .not</li>
          <li>.true, .false, .undefined, .NaN, .exist,</li>
          <li>.equal(<value>), .deep.equal(<value>)</li>
          <li>.includes([…<values>]), .any.keys, .all.keys</li>
          <li>.a(<baseType>), instanceOf(<class>)</li>
          <li>throws()</li>
        </ul>
      </p>
      <p>
        <span class="subtitle">Test Doubles:</span>Abhängigkeiten möglichst Lose, für tests Doubles verwenden
        Stub & Fake: liefern vorbestimmten Wert
        --- Spy & Mock: Helfen einen überprüfbaren Content zu generieren
      </p>
      <p>
        <span class="subtitle">Test-Smells:</span>
      </p>
    </div>
    
  </div>
  <div class="container page2">
    <div class="item itemSmall row1" style="min-height: 21cm;">blablablabla blablablablablabla blablablabla</div>
    <div class="item itemSmall row2" style="min-height: 10.5cm;">blablablabla blablablablablabla blablablabla blablablabla bl4blablablabla </div>
    <div class="item itemSmall row2" style="min-height: 10.5cm;">blablablabla blablablablablabla blablablabla blablablabla bl4blablablabla </div>
    <div class="item itemSmall row3" style="min-height: 21cm;">blablablablablab lablabla blablablablablab lablabla blablablabla</div>
    <div class="item itemSmall row4" style="min-height: 21cm;">blablablabla bla lablablablablabla lablab</div>
  </div>
  <script src="./node_modules/prismjs/prism.js"></script>
  <script>
    function titleColorAssigner(selector, colors) {
      let colorIndex = 0;
      document.querySelectorAll (selector).forEach(function (span) {
        span.style.background = colors[colorIndex];
        if (colorIndex === colors.length - 1) {
          colorIndex = 0;
        } else {
          colorIndex++;
        }
      });
    }
    window.onload = () => {
      titleColorAssigner(".subtitle", ["yellow", "aqua", "magenta"]);
      titleColorAssigner("h1", ["darksalmon", "burlywood", "chocolate"]);
    };
  </script>
</body>
</html>